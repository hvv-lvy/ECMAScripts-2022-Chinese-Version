# 5 符号约定
## 5.1 语法和词法
### 5.1.1 上下文无关语法
上下文无关语法由一些生产式组成。每个生产式包含了在左侧名为非终结符的抽象符号，以及在右侧一系列零或者更多的非终结符和终结符。对于每一种语法，终结符都取自指定的符号。

一个产生式链是一个只含有一个非终结符以及 0 个或多个终结符作为其右值的产生式。

句子中单一可区分的非终结符——目标符，给定一个语言上下文无关文法。换句话说，重复用产生式右值替换序列中任何左值为非终结符所组成的终结符序列集合(可能是无限个)。

### 5.1.2 词法与正则文法
ECMAScript 词法文法在条款12给出。词法文法拥有符合 11.1 定义的 SourceCharacter 规则的终结符 Unicode 码点。它定义了一套产生式，从目标符 InputElementDiv, InputElementTemplateTail,或 InputElementRegExp, InputElementRegExpOrTemplateTail 起始，描述如何将这样的字符序列翻译成一个输入元素序列。

空白和注释之外的输入元素构成 ECMAScript 语法文法的终结符，它们被称为ECMAScript词法单元（ tokens）。这些 tokens 是，ECMAScript 语言的保留字，标识符，字面量，标点符号。此外，行结束符虽然不被视为 tokens，但会成为输入元素流的一部分，用于引导处理自动插入分号(12.9)。单个空白和单行注释会的丢弃，不会出现在语法文法的输入元素的流中。如果一个 MultiLineComment（即形式为 /*…*/ 的注释，不管是否跨越多行）不包含行结束符也会直接地丢弃，但如果一个 MultiLineComment 包含一个或多个结束符，那么，注释会被替换为一个行结束符，成为语法文法输入元素流的一部分。

22.2.1 给出了 ECMAScript 的正则文法。此文法的终结符字符也由 SourceCharacter 定义。它定义了一套产生式，从目标符 Pattern 起始，描述了如何将这样的字符序列翻译成一个正则表达式模式。

两个冒号 "::" 作为分隔符分割词法和正则的文法产生式。词法和正则的文法共享某些产生式。

### 5.1.3 数字字符串文法
用于转换字符串为数字值的一种文法。此文法与数字字面量词法文法的一部分类似，并且有终结符 SourceCharacter。此文法出现在 7.1.4.1。

三个冒号 ":::" 作为分隔符分割数字字符串文法的产生式。

### 5.1.4 语法文法
第 13-16 章给出了 ECMAScript 的语法文法。词法文法定义的 ECMAScript tokens 是此文法的终结符(5.1.2)。它定义了一系列的产生式，从两个可选的目标符号 Script 以及 Module 开始，描述了形成 ECMAScript 程序语法上正常的独立的组件的词法单元（token）是怎样的序列。

当一个码点流解析成一个 ECMAScript 的 Script 或者 Module 时，它首先被词法文法程序转换成一个输入元素流；然后使用一个单一语法文法程序解析这个输入元素流。存在语法错误 —— 输入元素流中的词法单元（token）不能被解析成一个单一的目标非终结符（Script 或者 Module）—— 的输入流，将不会留下任何词法单元（token）。

当一个解析成功的时候，它会构造一颗解析树，一颗根树结构是它的每个节点都是一个 Parse Node。每个 Parse Node 都是文法中的一个符号的一个实例。它代表了从这样的符号中派生出来的源代码文本的一个跨度。解析树的根节点代表着整个的源代码文本，是解析的目标符的一个实例。当一个 Parse Node 是一个非终结符的实例的时候，它也是某些左值为非终结符的产生式的一个实例。此外，它有 0 个或多个孩子，产生式右值中的每个符号：每个孩子的 Parse Node 都是相应符号的一个实例。

新的 Parse Nodes 在每次调用解析器时都会被重新实例化，也就是说解析相同源文本也永远不会重用。当且仅当它们表示相同的源文本范围，是相同语法符号的实例，并且是由调用相同的解析器产生的解析节点时被认为是相同的 Parse Node

> NOTE 1
多次解析同一字符串会得到不同的 Parse Nodes，例如：
```
let str = "1 + 1;";
eval(str);
eval(str);
```
> eval的每次调用都会将str的值转称EACMAScript源文本，执行独立的解析创建单独的节点（Parse NOdes）树。这些树是不同的，尽管每次解析操作的源文本都来自同一个字符串值

> NOTE 2
Parse Nodes 是规范的人为定义，并且不需要使用类似的数据结构来实现。


只用一个冒号 “:” 作为分隔符分割语法词法的产生式。

语法文法在条款 13-16 中提出。但是对于哪些词法单元（token）序列是正确被 ECMAScript Script 或者 Module 接受的解释得并不完整。一些额外的词法单元（token）序列也能被接受，换句话说，那些序列将会被文法描述，只要分号被加入到序列中的某些地方（比如在行终结符之前）。此外，某些通过文法描述的词法单元（token）序列不会被接受，如果一个行终结符出现在某些 “awkward” 的地方。

在某些情况下，为了避免歧义，语法文法使用广义的产生式，允许词法单元（token）序列形成一个不合法的 ECMAScript Script 或者 Module。例如，此技术被用作对象字面量和对象解构模式中。在这种情况下，提供了更加限制性的补充文法，其进一步限制可接受的词法单元（token）序列。通常，如果 "P is not covering an N"，则一个早期错误规则将会定义一个错误条件，其中 P 是 Parse Node（普通产生式的一个实例），N 是补充文法的非终结符。这里，最初与 P 匹配的词法单元（token）序列被再次用 N 作为目标符号解析。（如果 N 使用语法参数，则将它们设置为当 P 最初解析时使用的相同值）。如果词法单元（token）序列不能被解析为 N 的一个单一实例，则会产生错误，将不会留下任何 token。随后，算法访问 "the N that is covered by P" 的短语的解析结果。这将始终是一个解析节点（N 的一个实例，对于一个给定的 P 是唯一的），因此任何解析失败都将被一个早期错误规则检测到。

### 5.1.5 文法标记法